{"version":3,"file":"static/js/1475.0c440352.chunk.js","mappings":"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","sources":["../node_modules/@wagmi/connectors/src/coinbaseWallet.ts","../node_modules/@wagmi/connectors/src/safe.ts"],"sourcesContent":["import type {\n  Preference,\n  ProviderInterface,\n  createCoinbaseWalletSDK,\n} from '@coinbase/wallet-sdk'\nimport {\n  ChainNotConfiguredError,\n  type Connector,\n  createConnector,\n} from '@wagmi/core'\nimport type { Compute, Mutable, Omit } from '@wagmi/core/internal'\nimport type {\n  CoinbaseWalletProvider as CBW_Provider,\n  CoinbaseWalletSDK as CBW_SDK,\n} from 'cbw-sdk'\nimport {\n  type AddEthereumChainParameter,\n  type Address,\n  type Hex,\n  type ProviderRpcError,\n  SwitchChainError,\n  UserRejectedRequestError,\n  getAddress,\n  numberToHex,\n} from 'viem'\n\ntype Version = '3' | '4'\n\nexport type CoinbaseWalletParameters<version extends Version = '3'> =\n  version extends '4'\n    ? Compute<\n        {\n          headlessMode?: false | undefined\n          /** Coinbase Wallet SDK version */\n          version?: version | '3' | undefined\n        } & Version4Parameters\n      >\n    : Compute<\n        {\n          /**\n           * @deprecated `headlessMode` will be removed in the next major version. Upgrade to `version: '4'`.\n           */\n          headlessMode?: true | undefined\n          /**\n           * Coinbase Wallet SDK version\n           * @deprecated Version 3 will be removed in the next major version. Upgrade to `version: '4'`.\n           * @default '4'\n           */\n          version?: version | '4' | undefined\n        } & Version3Parameters\n      >\n\ncoinbaseWallet.type = 'coinbaseWallet' as const\nexport function coinbaseWallet<version extends Version>(\n  parameters: CoinbaseWalletParameters<version> = {} as any,\n): version extends '4'\n  ? ReturnType<typeof version4>\n  : ReturnType<typeof version3> {\n  if (parameters.version === '3' || parameters.headlessMode)\n    return version3(parameters as Version3Parameters) as any\n  return version4(parameters as Version4Parameters) as any\n}\n\ntype Version4Parameters = Mutable<\n  Omit<\n    Parameters<typeof createCoinbaseWalletSDK>[0],\n    | 'appChainIds' // set via wagmi config\n    | 'preference'\n  > & {\n    // TODO(v3): Remove `Preference['options']`\n    /**\n     * Preference for the type of wallet to display.\n     * @default 'all'\n     */\n    preference?: Preference['options'] | Compute<Preference> | undefined\n  }\n>\n\nfunction version4(parameters: Version4Parameters) {\n  type Provider = ProviderInterface & {\n    // for backwards compatibility\n    close?(): void\n  }\n  type Properties = {\n    connect(parameters?: {\n      chainId?: number | undefined\n      instantOnboarding?: boolean | undefined\n      isReconnecting?: boolean | undefined\n    }): Promise<{\n      accounts: readonly Address[]\n      chainId: number\n    }>\n  }\n\n  let walletProvider: Provider | undefined\n\n  let accountsChanged: Connector['onAccountsChanged'] | undefined\n  let chainChanged: Connector['onChainChanged'] | undefined\n  let disconnect: Connector['onDisconnect'] | undefined\n\n  return createConnector<Provider, Properties>((config) => ({\n    id: 'coinbaseWalletSDK',\n    name: 'Coinbase Wallet',\n    rdns: 'com.coinbase.wallet',\n    type: coinbaseWallet.type,\n    async connect({ chainId, ...rest } = {}) {\n      try {\n        const provider = await this.getProvider()\n        const accounts = (\n          (await provider.request({\n            method: 'eth_requestAccounts',\n            params:\n              'instantOnboarding' in rest && rest.instantOnboarding\n                ? [{ onboarding: 'instant' }]\n                : [],\n          })) as string[]\n        ).map((x) => getAddress(x))\n\n        if (!accountsChanged) {\n          accountsChanged = this.onAccountsChanged.bind(this)\n          provider.on('accountsChanged', accountsChanged)\n        }\n        if (!chainChanged) {\n          chainChanged = this.onChainChanged.bind(this)\n          provider.on('chainChanged', chainChanged)\n        }\n        if (!disconnect) {\n          disconnect = this.onDisconnect.bind(this)\n          provider.on('disconnect', disconnect)\n        }\n\n        // Switch to chain if provided\n        let currentChainId = await this.getChainId()\n        if (chainId && currentChainId !== chainId) {\n          const chain = await this.switchChain!({ chainId }).catch((error) => {\n            if (error.code === UserRejectedRequestError.code) throw error\n            return { id: currentChainId }\n          })\n          currentChainId = chain?.id ?? currentChainId\n        }\n\n        return { accounts, chainId: currentChainId }\n      } catch (error) {\n        if (\n          /(user closed modal|accounts received is empty|user denied account|request rejected)/i.test(\n            (error as Error).message,\n          )\n        )\n          throw new UserRejectedRequestError(error as Error)\n        throw error\n      }\n    },\n    async disconnect() {\n      const provider = await this.getProvider()\n\n      if (accountsChanged) {\n        provider.removeListener('accountsChanged', accountsChanged)\n        accountsChanged = undefined\n      }\n      if (chainChanged) {\n        provider.removeListener('chainChanged', chainChanged)\n        chainChanged = undefined\n      }\n      if (disconnect) {\n        provider.removeListener('disconnect', disconnect)\n        disconnect = undefined\n      }\n\n      provider.disconnect()\n      provider.close?.()\n    },\n    async getAccounts() {\n      const provider = await this.getProvider()\n      return (\n        (await provider.request({\n          method: 'eth_accounts',\n        })) as string[]\n      ).map((x) => getAddress(x))\n    },\n    async getChainId() {\n      const provider = await this.getProvider()\n      const chainId = (await provider.request({\n        method: 'eth_chainId',\n      })) as Hex\n      return Number(chainId)\n    },\n    async getProvider() {\n      if (!walletProvider) {\n        const preference = (() => {\n          if (typeof parameters.preference === 'string')\n            return { options: parameters.preference }\n          return {\n            ...parameters.preference,\n            options: parameters.preference?.options ?? 'all',\n          }\n        })()\n\n        const { createCoinbaseWalletSDK } = await import('@coinbase/wallet-sdk')\n        const sdk = createCoinbaseWalletSDK({\n          ...parameters,\n          appChainIds: config.chains.map((x) => x.id),\n          preference,\n        })\n\n        walletProvider = sdk.getProvider()\n      }\n\n      return walletProvider\n    },\n    async isAuthorized() {\n      try {\n        const accounts = await this.getAccounts()\n        return !!accounts.length\n      } catch {\n        return false\n      }\n    },\n    async switchChain({ addEthereumChainParameter, chainId }) {\n      const chain = config.chains.find((chain) => chain.id === chainId)\n      if (!chain) throw new SwitchChainError(new ChainNotConfiguredError())\n\n      const provider = await this.getProvider()\n\n      try {\n        await provider.request({\n          method: 'wallet_switchEthereumChain',\n          params: [{ chainId: numberToHex(chain.id) }],\n        })\n        return chain\n      } catch (error) {\n        // Indicates chain is not added to provider\n        if ((error as ProviderRpcError).code === 4902) {\n          try {\n            let blockExplorerUrls: string[] | undefined\n            if (addEthereumChainParameter?.blockExplorerUrls)\n              blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls\n            else\n              blockExplorerUrls = chain.blockExplorers?.default.url\n                ? [chain.blockExplorers?.default.url]\n                : []\n\n            let rpcUrls: readonly string[]\n            if (addEthereumChainParameter?.rpcUrls?.length)\n              rpcUrls = addEthereumChainParameter.rpcUrls\n            else rpcUrls = [chain.rpcUrls.default?.http[0] ?? '']\n\n            const addEthereumChain = {\n              blockExplorerUrls,\n              chainId: numberToHex(chainId),\n              chainName: addEthereumChainParameter?.chainName ?? chain.name,\n              iconUrls: addEthereumChainParameter?.iconUrls,\n              nativeCurrency:\n                addEthereumChainParameter?.nativeCurrency ??\n                chain.nativeCurrency,\n              rpcUrls,\n            } satisfies AddEthereumChainParameter\n\n            await provider.request({\n              method: 'wallet_addEthereumChain',\n              params: [addEthereumChain],\n            })\n\n            return chain\n          } catch (error) {\n            throw new UserRejectedRequestError(error as Error)\n          }\n        }\n\n        throw new SwitchChainError(error as Error)\n      }\n    },\n    onAccountsChanged(accounts) {\n      if (accounts.length === 0) this.onDisconnect()\n      else\n        config.emitter.emit('change', {\n          accounts: accounts.map((x) => getAddress(x)),\n        })\n    },\n    onChainChanged(chain) {\n      const chainId = Number(chain)\n      config.emitter.emit('change', { chainId })\n    },\n    async onDisconnect(_error) {\n      config.emitter.emit('disconnect')\n\n      const provider = await this.getProvider()\n      if (accountsChanged) {\n        provider.removeListener('accountsChanged', accountsChanged)\n        accountsChanged = undefined\n      }\n      if (chainChanged) {\n        provider.removeListener('chainChanged', chainChanged)\n        chainChanged = undefined\n      }\n      if (disconnect) {\n        provider.removeListener('disconnect', disconnect)\n        disconnect = undefined\n      }\n    },\n  }))\n}\n\ntype Version3Parameters = Mutable<\n  Omit<\n    ConstructorParameters<typeof CBW_SDK>[0],\n    'reloadOnDisconnect' // remove property since TSDoc says default is `true`\n  >\n> & {\n  /**\n   * Fallback Ethereum JSON RPC URL\n   * @default \"\"\n   */\n  jsonRpcUrl?: string | undefined\n  /**\n   * Fallback Ethereum Chain ID\n   * @default 1\n   */\n  chainId?: number | undefined\n  /**\n   * Whether or not to reload dapp automatically after disconnect.\n   * @default false\n   */\n  reloadOnDisconnect?: boolean | undefined\n}\n\nfunction version3(parameters: Version3Parameters) {\n  const reloadOnDisconnect = false\n\n  type Provider = CBW_Provider\n\n  let sdk: CBW_SDK | undefined\n  let walletProvider: Provider | undefined\n\n  let accountsChanged: Connector['onAccountsChanged'] | undefined\n  let chainChanged: Connector['onChainChanged'] | undefined\n  let disconnect: Connector['onDisconnect'] | undefined\n\n  return createConnector<Provider>((config) => ({\n    id: 'coinbaseWalletSDK',\n    name: 'Coinbase Wallet',\n    rdns: 'com.coinbase.wallet',\n    type: coinbaseWallet.type,\n    async connect({ chainId } = {}) {\n      try {\n        const provider = await this.getProvider()\n        const accounts = (\n          (await provider.request({\n            method: 'eth_requestAccounts',\n          })) as string[]\n        ).map((x) => getAddress(x))\n\n        if (!accountsChanged) {\n          accountsChanged = this.onAccountsChanged.bind(this)\n          provider.on('accountsChanged', accountsChanged)\n        }\n        if (!chainChanged) {\n          chainChanged = this.onChainChanged.bind(this)\n          provider.on('chainChanged', chainChanged)\n        }\n        if (!disconnect) {\n          disconnect = this.onDisconnect.bind(this)\n          provider.on('disconnect', disconnect)\n        }\n\n        // Switch to chain if provided\n        let currentChainId = await this.getChainId()\n        if (chainId && currentChainId !== chainId) {\n          const chain = await this.switchChain!({ chainId }).catch((error) => {\n            if (error.code === UserRejectedRequestError.code) throw error\n            return { id: currentChainId }\n          })\n          currentChainId = chain?.id ?? currentChainId\n        }\n\n        return { accounts, chainId: currentChainId }\n      } catch (error) {\n        if (\n          /(user closed modal|accounts received is empty|user denied account)/i.test(\n            (error as Error).message,\n          )\n        )\n          throw new UserRejectedRequestError(error as Error)\n        throw error\n      }\n    },\n    async disconnect() {\n      const provider = await this.getProvider()\n\n      if (accountsChanged) {\n        provider.removeListener('accountsChanged', accountsChanged)\n        accountsChanged = undefined\n      }\n      if (chainChanged) {\n        provider.removeListener('chainChanged', chainChanged)\n        chainChanged = undefined\n      }\n      if (disconnect) {\n        provider.removeListener('disconnect', disconnect)\n        disconnect = undefined\n      }\n\n      provider.disconnect()\n      provider.close()\n    },\n    async getAccounts() {\n      const provider = await this.getProvider()\n      return (\n        await provider.request<string[]>({\n          method: 'eth_accounts',\n        })\n      ).map((x) => getAddress(x))\n    },\n    async getChainId() {\n      const provider = await this.getProvider()\n      const chainId = await provider.request<Hex>({\n        method: 'eth_chainId',\n      })\n      return Number(chainId)\n    },\n    async getProvider() {\n      if (!walletProvider) {\n        // Unwrapping import for Vite compatibility.\n        // See: https://github.com/vitejs/vite/issues/9703\n        const CoinbaseWalletSDK = await (async () => {\n          const { default: SDK } = await import('cbw-sdk')\n          if (typeof SDK !== 'function' && typeof SDK.default === 'function')\n            return SDK.default\n          return SDK as unknown as typeof SDK.default\n        })()\n\n        sdk = new CoinbaseWalletSDK({ ...parameters, reloadOnDisconnect })\n\n        // Force types to retrieve private `walletExtension` method from the Coinbase Wallet SDK.\n        const walletExtensionChainId = (\n          sdk as unknown as {\n            get walletExtension(): { getChainId(): number } | undefined\n          }\n        ).walletExtension?.getChainId()\n\n        const chain =\n          config.chains.find((chain) =>\n            parameters.chainId\n              ? chain.id === parameters.chainId\n              : chain.id === walletExtensionChainId,\n          ) || config.chains[0]\n        const chainId = parameters.chainId || chain?.id\n        const jsonRpcUrl =\n          parameters.jsonRpcUrl || chain?.rpcUrls.default.http[0]\n\n        walletProvider = sdk.makeWeb3Provider(jsonRpcUrl, chainId)\n      }\n\n      return walletProvider\n    },\n    async isAuthorized() {\n      try {\n        const accounts = await this.getAccounts()\n        return !!accounts.length\n      } catch {\n        return false\n      }\n    },\n    async switchChain({ addEthereumChainParameter, chainId }) {\n      const chain = config.chains.find((chain) => chain.id === chainId)\n      if (!chain) throw new SwitchChainError(new ChainNotConfiguredError())\n\n      const provider = await this.getProvider()\n\n      try {\n        await provider.request({\n          method: 'wallet_switchEthereumChain',\n          params: [{ chainId: numberToHex(chain.id) }],\n        })\n        return chain\n      } catch (error) {\n        // Indicates chain is not added to provider\n        if ((error as ProviderRpcError).code === 4902) {\n          try {\n            let blockExplorerUrls: string[] | undefined\n            if (addEthereumChainParameter?.blockExplorerUrls)\n              blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls\n            else\n              blockExplorerUrls = chain.blockExplorers?.default.url\n                ? [chain.blockExplorers?.default.url]\n                : []\n\n            let rpcUrls: readonly string[]\n            if (addEthereumChainParameter?.rpcUrls?.length)\n              rpcUrls = addEthereumChainParameter.rpcUrls\n            else rpcUrls = [chain.rpcUrls.default?.http[0] ?? '']\n\n            const addEthereumChain = {\n              blockExplorerUrls,\n              chainId: numberToHex(chainId),\n              chainName: addEthereumChainParameter?.chainName ?? chain.name,\n              iconUrls: addEthereumChainParameter?.iconUrls,\n              nativeCurrency:\n                addEthereumChainParameter?.nativeCurrency ??\n                chain.nativeCurrency,\n              rpcUrls,\n            } satisfies AddEthereumChainParameter\n\n            await provider.request({\n              method: 'wallet_addEthereumChain',\n              params: [addEthereumChain],\n            })\n\n            return chain\n          } catch (error) {\n            throw new UserRejectedRequestError(error as Error)\n          }\n        }\n\n        throw new SwitchChainError(error as Error)\n      }\n    },\n    onAccountsChanged(accounts) {\n      if (accounts.length === 0) this.onDisconnect()\n      else\n        config.emitter.emit('change', {\n          accounts: accounts.map((x) => getAddress(x)),\n        })\n    },\n    onChainChanged(chain) {\n      const chainId = Number(chain)\n      config.emitter.emit('change', { chainId })\n    },\n    async onDisconnect(_error) {\n      config.emitter.emit('disconnect')\n\n      const provider = await this.getProvider()\n      if (accountsChanged) {\n        provider.removeListener('accountsChanged', accountsChanged)\n        accountsChanged = undefined\n      }\n      if (chainChanged) {\n        provider.removeListener('chainChanged', chainChanged)\n        chainChanged = undefined\n      }\n      if (disconnect) {\n        provider.removeListener('disconnect', disconnect)\n        disconnect = undefined\n      }\n    },\n  }))\n}\n","import type { SafeAppProvider } from '@safe-global/safe-apps-provider'\nimport type { Opts } from '@safe-global/safe-apps-sdk'\nimport {\n  type Connector,\n  ProviderNotFoundError,\n  createConnector,\n} from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport { getAddress, withTimeout } from 'viem'\n\nexport type SafeParameters = Compute<\n  Opts & {\n    /**\n     * Connector automatically connects when used as Safe App.\n     *\n     * This flag simulates the disconnect behavior by keeping track of connection status in storage\n     * and only autoconnecting when previously connected by user action (e.g. explicitly choosing to connect).\n     *\n     * @default false\n     */\n    shimDisconnect?: boolean | undefined\n    /**\n     * Timeout in milliseconds for `getInfo` (from the Safe SDK) to resolve.\n     *\n     * `getInfo` does not resolve when not used in Safe App iFrame. This allows the connector to force a timeout.\n     * @default 10\n     */\n    unstable_getInfoTimeout?: number | undefined\n  }\n>\n\nsafe.type = 'safe' as const\nexport function safe(parameters: SafeParameters = {}) {\n  const { shimDisconnect = false } = parameters\n\n  type Provider = SafeAppProvider | undefined\n  type Properties = Record<string, unknown>\n  type StorageItem = { 'safe.disconnected': true }\n\n  let provider_: Provider | undefined\n\n  let disconnect: Connector['onDisconnect'] | undefined\n\n  return createConnector<Provider, Properties, StorageItem>((config) => ({\n    id: 'safe',\n    name: 'Safe',\n    type: safe.type,\n    async connect() {\n      const provider = await this.getProvider()\n      if (!provider) throw new ProviderNotFoundError()\n\n      const accounts = await this.getAccounts()\n      const chainId = await this.getChainId()\n\n      if (!disconnect) {\n        disconnect = this.onDisconnect.bind(this)\n        provider.on('disconnect', disconnect)\n      }\n\n      // Remove disconnected shim if it exists\n      if (shimDisconnect) await config.storage?.removeItem('safe.disconnected')\n\n      return { accounts, chainId }\n    },\n    async disconnect() {\n      const provider = await this.getProvider()\n      if (!provider) throw new ProviderNotFoundError()\n\n      if (disconnect) {\n        provider.removeListener('disconnect', disconnect)\n        disconnect = undefined\n      }\n\n      // Add shim signalling connector is disconnected\n      if (shimDisconnect)\n        await config.storage?.setItem('safe.disconnected', true)\n    },\n    async getAccounts() {\n      const provider = await this.getProvider()\n      if (!provider) throw new ProviderNotFoundError()\n      return (await provider.request({ method: 'eth_accounts' })).map(\n        getAddress,\n      )\n    },\n    async getProvider() {\n      // Only allowed in iframe context\n      const isIframe =\n        typeof window !== 'undefined' && window?.parent !== window\n      if (!isIframe) return\n\n      if (!provider_) {\n        const { default: SDK } = await import('@safe-global/safe-apps-sdk')\n        const sdk = new SDK(parameters)\n\n        // `getInfo` hangs when not used in Safe App iFrame\n        // https://github.com/safe-global/safe-apps-sdk/issues/263#issuecomment-1029835840\n        const safe = await withTimeout(() => sdk.safe.getInfo(), {\n          timeout: parameters.unstable_getInfoTimeout ?? 10,\n        })\n        if (!safe) throw new Error('Could not load Safe information')\n        // Unwrapping import for Vite compatibility.\n        // See: https://github.com/vitejs/vite/issues/9703\n        const SafeAppProvider = await (async () => {\n          const Provider = await import('@safe-global/safe-apps-provider')\n          if (\n            typeof Provider.SafeAppProvider !== 'function' &&\n            typeof Provider.default.SafeAppProvider === 'function'\n          )\n            return Provider.default.SafeAppProvider\n          return Provider.SafeAppProvider\n        })()\n        provider_ = new SafeAppProvider(safe, sdk)\n      }\n      return provider_\n    },\n    async getChainId() {\n      const provider = await this.getProvider()\n      if (!provider) throw new ProviderNotFoundError()\n      return Number(provider.chainId)\n    },\n    async isAuthorized() {\n      try {\n        const isDisconnected =\n          shimDisconnect &&\n          // If shim exists in storage, connector is disconnected\n          (await config.storage?.getItem('safe.disconnected'))\n        if (isDisconnected) return false\n\n        const accounts = await this.getAccounts()\n        return !!accounts.length\n      } catch {\n        return false\n      }\n    },\n    onAccountsChanged() {\n      // Not relevant for Safe because changing account requires app reload.\n    },\n    onChainChanged() {\n      // Not relevant for Safe because Safe smart contract wallets only exist on single chain.\n    },\n    onDisconnect() {\n      config.emitter.emit('disconnect')\n    },\n  }))\n}\n"],"names":["coinbaseWallet","parameters","arguments","length","undefined","version","headlessMode","reloadOnDisconnect","sdk","walletProvider","accountsChanged","chainChanged","disconnect","createConnector","config","id","name","rdns","type","connect","chainId","provider","this","getProvider","accounts","request","method","map","x","getAddress","onAccountsChanged","bind","on","onChainChanged","onDisconnect","currentChainId","getChainId","_chain$id2","chain","switchChain","catch","error","code","UserRejectedRequestError","test","message","removeListener","close","getAccounts","Number","_sdk$walletExtension","CoinbaseWalletSDK","default","SDK","_objectSpread","walletExtensionChainId","walletExtension","chains","find","jsonRpcUrl","rpcUrls","http","makeWeb3Provider","isAuthorized","_unused2","_ref3","addEthereumChainParameter","SwitchChainError","ChainNotConfiguredError","params","numberToHex","_chain$blockExplorers3","_chain$blockExplorers4","_addEthereumChainPara4","_chain$rpcUrls$defaul3","_chain$rpcUrls$defaul4","_addEthereumChainPara5","_addEthereumChainPara6","blockExplorerUrls","blockExplorers","url","addEthereumChain","chainName","iconUrls","nativeCurrency","emitter","emit","_error","version3","_ref","rest","_objectWithoutProperties","_excluded","instantOnboarding","onboarding","_chain$id","_provider$close","call","preference","options","_parameters$preferenc","_parameters$preferenc2","createCoinbaseWalletSDK","appChainIds","_unused","_ref2","_chain$blockExplorers","_chain$blockExplorers2","_addEthereumChainPara","_chain$rpcUrls$defaul","_chain$rpcUrls$defaul2","_addEthereumChainPara2","_addEthereumChainPara3","version4","safe","shimDisconnect","provider_","_config$storage","ProviderNotFoundError","storage","removeItem","_config$storage2","setItem","_window","window","parent","_parameters$unstable_","withTimeout","getInfo","timeout","unstable_getInfoTimeout","Error","SafeAppProvider","Provider","_config$storage3","getItem"],"sourceRoot":""}